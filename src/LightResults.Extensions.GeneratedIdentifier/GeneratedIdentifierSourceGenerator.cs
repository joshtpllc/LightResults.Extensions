using System.Collections.Immutable;
using System.Text;
using LightResults.Extensions.GeneratedIdentifier.Common;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.Text;

namespace LightResults.Extensions.GeneratedIdentifier;

[Generator]
public sealed class GeneratedIdentifierSourceGenerator : IIncrementalGenerator
{
    private const string AttributesNamespace = "LightResults.Extensions.GeneratedIdentifier";
    private const string GeneratedIdentifierAttributeName = "GeneratedIdentifierAttribute";
    private const string GeneratedIdentifierAttributeFullyQualifiedName = $"{AttributesNamespace}.{GeneratedIdentifierAttributeName}`1";
    private const string GeneratedIdentifierAttributeHint = $"{GeneratedIdentifierAttributeFullyQualifiedName}.g.cs";

    private static readonly string FileHeader = $"""
                                                 //-----------------------------------------------------------------------------
                                                 // <auto-generated>
                                                 // This code was generated by {nameof(GeneratedIdentifierSourceGenerator)} which
                                                 // can be found in the {typeof(GeneratedIdentifierSourceGenerator).Namespace} namespace.
                                                 //
                                                 // Changes to this file may cause incorrect behavior
                                                 // and will be lost if the code is regenerated.
                                                 // </auto-generated>
                                                 //-----------------------------------------------------------------------------
                                                 #nullable enable
                                                 """;

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(RegisterAttributes);

        var generatedIdentifiers = context.SyntaxProvider
            .ForAttributeWithMetadataName(GeneratedIdentifierAttributeFullyQualifiedName, Filter, Transform)
            .WhereNotNull()
            .Collect();

        context.RegisterSourceOutput(generatedIdentifiers, GenerateIdentifier);
    }

    private static void RegisterAttributes(IncrementalGeneratorPostInitializationContext context)
    {
        var source = $"""
                      {FileHeader}

                      using System;

                      namespace {AttributesNamespace};

                      [AttributeUsage(AttributeTargets.Struct)]
                      public sealed class {GeneratedIdentifierAttributeName}<TIdentifier> : Attribute;
                      """;
        context.AddSource(GeneratedIdentifierAttributeHint, SourceText.From(source, Encoding.UTF8));
    }

    private static bool Filter(SyntaxNode syntaxNode, CancellationToken cancellationToken)
    {
        cancellationToken.ThrowIfCancellationRequested();

        return syntaxNode.IsKind(SyntaxKind.StructDeclaration);
    }

    private static Identifier? Transform(GeneratorAttributeSyntaxContext context, CancellationToken cancellationToken)
    {
        cancellationToken.ThrowIfCancellationRequested();

        if (context.TargetSymbol is not INamedTypeSymbol namedTypeSymbol)
            return null;

        var containingDeclarations = namedTypeSymbol.GetContainingDeclarations(cancellationToken);
        var symbolName = namedTypeSymbol.Name;

        var attribute = context.Attributes[0].AttributeClass!;
        if (attribute.TypeArguments.Length != 1)
            return null;

        var typeArgument = attribute.TypeArguments[0];

        string? declaredValueType;
        string? fullValueType;
        switch (typeArgument.SpecialType)
        {
            case SpecialType.System_Int16:
                declaredValueType = "short";
                fullValueType = "Int16";
                break;
            case SpecialType.System_Int32:
                declaredValueType = "int";
                fullValueType = "Int32";
                break;
            case SpecialType.System_Int64:
                declaredValueType = "long";
                fullValueType = "Int64";
                break;
            default:
                if (typeArgument is not { Name: "Guid", ContainingNamespace: { Name: "System", ContainingNamespace.IsGlobalNamespace: true } })
                    return null;
                declaredValueType = "Guid";
                fullValueType = "Guid";
                break;
        }

        var symbol = new Identifier(containingDeclarations, symbolName, declaredValueType, fullValueType);

        return symbol;
    }

    private static void GenerateIdentifier(SourceProductionContext context, ImmutableArray<Identifier> generatedIdentifiers)
    {
        foreach (var symbol in generatedIdentifiers)
        {
            var structNamespace = symbol.ContainingDeclarations.ToNamespace();
            var structName = symbol.Name;
            var declaredValueType = symbol.DeclaredValueType;
            var fullValueType = symbol.FullValueType;

            var source = new StringBuilder();

            source.AppendLine($"""
                               //-----------------------------------------------------------------------------
                               // <auto-generated>
                               // This code was generated by {nameof(GeneratedIdentifierSourceGenerator)} which
                               // can be found in the {typeof(GeneratedIdentifierSourceGenerator).Namespace} namespace.
                               //
                               // Changes to this file may cause incorrect behavior
                               // and will be lost if the code is regenerated.
                               // </auto-generated>
                               //-----------------------------------------------------------------------------

                               #nullable enable

                               using System.ComponentModel;
                               using System.Globalization;
                               using System.Text.Json;
                               using System.Text.Json.Serialization;
                               using LightResults;
                               using LightResults.Extensions.ValueObjects;

                               """
            );

            if (structNamespace.Length > 0)
                source.AppendLine($"""
                                   namespace {structNamespace};

                                   """
                );

            source.AppendLine($$"""
                                [TypeConverter(typeof({{structName}}TypeConverter))]
                                [JsonConverter(typeof({{structName}}JsonConverter))]
                                readonly partial struct {{structName}} :
                                    ICreatableValueObject<{{declaredValueType}}, {{structName}}>,
                                    IParsableValueObject<{{structName}}>,
                                    IValueObject<{{declaredValueType}}, {{structName}}>,
                                    IComparable<{{structName}}>,
                                    IComparable
                                {
                                """
            );

            source.AppendLine("""
                                  /// <summary>Gets whether this identifier is the default value.</summary>
                                  public bool IsDefault => _value == default;

                              """
            );

            source.AppendLine($"""
                                   {declaredValueType} IValueObject<{declaredValueType}, {structName}>.Value => _value;
                               
                                   private readonly {declaredValueType} _value;

                               """
            );

            source.AppendLine($$"""
                                    private {{structName}}({{declaredValueType}} value, bool skipValidation = false)
                                    {
                                        if (!skipValidation)
                                            ValueObjectException.ThrowIfFailed(Validate(value));
                                
                                        _value = value;
                                    }

                                """
            );

            source.AppendLine($$"""
                                    /// <inheritdoc />
                                    public static {{structName}} Create({{declaredValueType}} value)
                                    {
                                        var result = TryCreate(value);
                                        if (result.IsSuccess(out var identifier, out var error))
                                            return identifier;
                                
                                        throw new ValueObjectException(error.Message);
                                    }

                                """
            );

            source.AppendLine($$"""
                                    /// <inheritdoc />
                                    public static Result<{{structName}}> TryCreate({{declaredValueType}} value)
                                    {
                                        var validation = Validate(value);
                                        if (validation.IsFailed(out var error))
                                            return Result.Fail<{{structName}}>(error);
                                
                                        return Result.Ok<{{structName}}>(new {{structName}}(value, true));
                                    }

                                """
            );

            source.AppendLine($$"""
                                    /// <inheritdoc />
                                    public static {{structName}} Parse(string s)
                                    {
                                        var result = TryParse(s);
                                        if (result.IsSuccess(out var identifier, out var error))
                                            return identifier;
                                
                                        throw new ValueObjectException(error.Message);
                                    }

                                """
            );

            source.AppendLine($$"""
                                    /// <inheritdoc />
                                    public static Result<{{structName}}> TryParse(string s)
                                    {
                                        if ({{declaredValueType}}.TryParse(s, out var value))
                                            return TryCreate(value);
                                
                                        return Result.Fail<{{structName}}>("The string is not a valid identifier.");
                                    }

                                """
            );

            source.AppendLine($$"""
                                    /// <inheritdoc />
                                    public static bool TryParse(string s, out {{structName}} identifier)
                                    {
                                        return TryParse(s).IsSuccess(out identifier);
                                    }

                                """
            );

            source.AppendLine($$"""
                                    /// <inheritdoc />
                                    public static bool TryParse(string s, IFormatProvider provider, out {{structName}} identifier)
                                    {
                                        return TryParse(s).IsSuccess(out identifier);
                                    }

                                """
            );

            source.AppendLine($$"""
                                    /// <inheritdoc />
                                    public bool Equals({{structName}} other)
                                    {
                                        return _value == other._value;
                                    }

                                """
            );

            source.AppendLine($$"""
                                    /// <inheritdoc />
                                    public override bool Equals(object? obj)
                                    {
                                        return obj is {{structName}} other && Equals(other);
                                    }

                                """
            );

            if (declaredValueType == "Guid")
                source.AppendLine("""
                                      /// <inheritdoc />
                                      public override int GetHashCode()
                                      {
                                          return _value.GetHashCode();
                                      }

                                  """
                );
            else
                source.AppendLine("""
                                      /// <inheritdoc />
                                      public override int GetHashCode()
                                      {
                                          return _value;
                                      }

                                  """
                );

            source.AppendLine($$"""
                                    /// <summary>Determines whether two instances of <see cref="{{structName}}" /> are equal.</summary>
                                    /// <param name="left">The first instance to compare.</param>
                                    /// <param name="right">The second instance to compare.</param>
                                    /// <returns><c>true</c> if the instances are equal; otherwise, <c>false</c>.</returns>
                                    public static bool operator ==({{structName}} left, {{structName}} right)
                                    {
                                        return left.Equals(right);
                                    }

                                """
            );

            source.AppendLine($$"""
                                    /// <summary>Determines whether two instances of <see cref="{{structName}}" /> are not equal.</summary>
                                    /// <param name="left">The first instance to compare.</param>
                                    /// <param name="right">The second instance to compare.</param>
                                    /// <returns><c>true</c> if the instances are not equal; otherwise, <c>false</c>.</returns>
                                    public static bool operator !=({{structName}} left, {{structName}} right)
                                    {
                                        return !left.Equals(right);
                                    }

                                """
            );

            source.AppendLine($$"""
                                    /// <inheritdoc />
                                    public int CompareTo({{structName}} other)
                                    {
                                        return _value.CompareTo(other._value);
                                    }

                                """
            );

            source.AppendLine($$"""
                                    /// <inheritdoc />
                                    public int CompareTo(object? obj)
                                    {
                                        if (ReferenceEquals(null, obj)) return 1;
                                        return obj is {{structName}} other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof({{structName}})}");
                                    }

                                """
            );

            source.AppendLine($$"""
                                    /// <summary>Determines whether the first instance of <see cref="{{structName}}" /> is less than the second instance.</summary>
                                    /// <param name="left">The first instance to compare.</param>
                                    /// <param name="right">The second instance to compare.</param>
                                    /// <returns><c>true</c> if the first instance is less than the second instance; otherwise, <c>false</c>.</returns>
                                    public static bool operator <({{structName}} left, {{structName}} right)
                                    {
                                        return left.CompareTo(right) < 0;
                                    }

                                """
            );

            source.AppendLine($$"""
                                    /// <summary>Determines whether the first instance of <see cref="{{structName}}" /> is greater than the second instance.</summary>
                                    /// <param name="left">The first instance to compare.</param>
                                    /// <param name="right">The second instance to compare.</param>
                                    /// <returns><c>true</c> if the first instance is greater than the second instance; otherwise, <c>false</c>.</returns>
                                    public static bool operator >({{structName}} left, {{structName}} right)
                                    {
                                        return left.CompareTo(right) > 0;
                                    }

                                """
            );

            source.AppendLine($$"""
                                    /// <summary>Determines whether the first instance of <see cref="{{structName}}" /> is less than or equal to the second instance.</summary>
                                    /// <param name="left">The first instance to compare.</param>
                                    /// <param name="right">The second instance to compare.</param>
                                    /// <returns><c>true</c> if the first instance is less than or equal to the second instance; otherwise, <c>false</c>.</returns>
                                    public static bool operator <=({{structName}} left, {{structName}} right)
                                    {
                                        return left.CompareTo(right) <= 0;
                                    }

                                """
            );

            source.AppendLine($$"""
                                    /// <summary>Determines whether the first instance of <see cref="{{structName}}" /> is greater than or equal to the second instance.</summary>
                                    /// <param name="left">The first instance to compare.</param>
                                    /// <param name="right">The second instance to compare.</param>
                                    /// <returns><c>true</c> if the first instance is greater than or equal to the second instance; otherwise, <c>false</c>.</returns>
                                    public static bool operator >=({{structName}} left, {{structName}} right)
                                    {
                                        return left.CompareTo(right) >= 0;
                                    }

                                """
            );

            source.AppendLine($$"""
                                    /// <summary>Gets the underlying value of the <see cref="{{structName}}" />.</summary>
                                    /// <returns>The underlying value of the <see cref="{{structName}}" />.</returns>
                                    public {{declaredValueType}} To{{fullValueType}}()
                                    {
                                        return _value;
                                    }

                                """
            );

            if (declaredValueType == "Guid")
                source.AppendLine("""
                                      /// <inheritdoc />
                                      public override string ToString()
                                      {
                                          return _value.ToString();
                                      }

                                  """
                );
            else
                source.AppendLine("""
                                      /// <inheritdoc />
                                      public override string ToString()
                                      {
                                          return _value.ToString(CultureInfo.InvariantCulture);
                                      }

                                  """
                );

            if (declaredValueType == "Guid")
                source.AppendLine($$"""
                                        private static Result Validate({{declaredValueType}} value)
                                        {
                                            return Result.Ok();
                                        }
                                    """
                );
            else
                source.AppendLine($$"""
                                        private static Result Validate({{declaredValueType}} value)
                                        {
                                            if (value < 0)
                                                return Result.Fail("The value must be equal to or greater than zero.");
                                    
                                            return Result.Ok();
                                        }
                                    """
                );

            source.AppendLine("""
                              }

                              """
            );

            source.AppendLine($$"""
                                public class {{structName}}TypeConverter : TypeConverter
                                {
                                    public override bool CanConvertFrom(ITypeDescriptorContext? context, Type sourceType)
                                    {
                                        return sourceType == typeof({{declaredValueType}}) || base.CanConvertFrom(context, sourceType);
                                    }
                                
                                    public override object? ConvertFrom(ITypeDescriptorContext? context, CultureInfo? culture, object value)
                                    {
                                        if (value is {{declaredValueType}} identifierValue)
                                            return {{structName}}.Create(identifierValue);
                                
                                        return base.ConvertFrom(context, culture, value);
                                    }
                                }

                                """
            );
            source.AppendLine($$"""
                                public class {{structName}}JsonConverter : JsonConverter<{{structName}}>
                                {
                                    public override void Write(Utf8JsonWriter writer, {{structName}} identifier, JsonSerializerOptions options)
                                    {
                                        var value = ((IValueObject<{{declaredValueType}}, {{structName}}>)identifier).Value;
                                """
            );

            if (declaredValueType == "Guid")
                source.AppendLine("""        writer.WriteStringValue(value.ToString());""");
            else
                source.AppendLine("""        writer.WriteNumberValue(value);""");

            source.Append($$"""
                                }
                            
                                public override {{structName}} Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
                                {
                                    var value = reader.Get{{fullValueType}}();
                                    return {{structName}}.Create(value);
                                }
                            }

                            """
            );

            var hint = $"{symbol.ContainingDeclarations.ToFullyQualifiedName()}.{symbol.Name}.g.cs";
            context.AddSource(hint, source.ToString());
        }
    }

    private readonly record struct Identifier(
        EquatableImmutableArray<Declaration> ContainingDeclarations,
        string Name,
        string DeclaredValueType,
        string FullValueType
    )
    {
        public EquatableImmutableArray<Declaration> ContainingDeclarations { get; } = ContainingDeclarations;
        public string Name { get; } = Name;
        public string DeclaredValueType { get; } = DeclaredValueType;
        public string FullValueType { get; } = FullValueType;
    }
}
